// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Wed, 01 Feb 2017 05:13:32 MSK.
// By https://git.io/c-for-go. DO NOT EDIT.

package hamlib

/*
#cgo pkg-config: hamlib
#include "hamlib/rig.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// Ref returns a reference to C object as it is.
func (x *Rig) Ref() *C.RIG {
	if x == nil {
		return nil
	}
	return (*C.RIG)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Rig) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewRigRef converts the C object reference into a raw struct reference without wrapping.
func NewRigRef(ref unsafe.Pointer) *Rig {
	return (*Rig)(ref)
}

// NewRig allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewRig() *Rig {
	return (*Rig)(allocRigMemory(1))
}

// allocRigMemory allocates memory for type C.RIG in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRigValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRigValue = unsafe.Sizeof([1]C.RIG{})

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Rig) PassRef() *C.RIG {
	if x == nil {
		x = (*Rig)(allocRigMemory(1))
	}
	return (*C.RIG)(unsafe.Pointer(x))
}

// allocFreqRangeMemory allocates memory for type C.freq_range_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFreqRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFreqRangeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFreqRangeValue = unsafe.Sizeof([1]C.freq_range_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FreqRange) Ref() *C.freq_range_t {
	if x == nil {
		return nil
	}
	return x.ref5a1ffb63
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FreqRange) Free() {
	if x != nil && x.allocs5a1ffb63 != nil {
		x.allocs5a1ffb63.(*cgoAllocMap).Free()
		x.ref5a1ffb63 = nil
	}
}

// NewFreqRangeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFreqRangeRef(ref unsafe.Pointer) *FreqRange {
	if ref == nil {
		return nil
	}
	obj := new(FreqRange)
	obj.ref5a1ffb63 = (*C.freq_range_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FreqRange) PassRef() (*C.freq_range_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5a1ffb63 != nil {
		return x.ref5a1ffb63, nil
	}
	mem5a1ffb63 := allocFreqRangeMemory(1)
	ref5a1ffb63 := (*C.freq_range_t)(mem5a1ffb63)
	allocs5a1ffb63 := new(cgoAllocMap)
	var cstart_allocs *cgoAllocMap
	ref5a1ffb63.start, cstart_allocs = (C.freq_t)(x.Start), cgoAllocsUnknown
	allocs5a1ffb63.Borrow(cstart_allocs)

	var cend_allocs *cgoAllocMap
	ref5a1ffb63.end, cend_allocs = (C.freq_t)(x.End), cgoAllocsUnknown
	allocs5a1ffb63.Borrow(cend_allocs)

	var cmodes_allocs *cgoAllocMap
	ref5a1ffb63.modes, cmodes_allocs = (C.rmode_t)(x.Modes), cgoAllocsUnknown
	allocs5a1ffb63.Borrow(cmodes_allocs)

	var clow_power_allocs *cgoAllocMap
	ref5a1ffb63.low_power, clow_power_allocs = (C.int)(x.LowPower), cgoAllocsUnknown
	allocs5a1ffb63.Borrow(clow_power_allocs)

	var chigh_power_allocs *cgoAllocMap
	ref5a1ffb63.high_power, chigh_power_allocs = (C.int)(x.HighPower), cgoAllocsUnknown
	allocs5a1ffb63.Borrow(chigh_power_allocs)

	var cvfo_allocs *cgoAllocMap
	ref5a1ffb63.vfo, cvfo_allocs = (C.vfo_t)(x.Vfo), cgoAllocsUnknown
	allocs5a1ffb63.Borrow(cvfo_allocs)

	var cant_allocs *cgoAllocMap
	ref5a1ffb63.ant, cant_allocs = (C.ant_t)(x.Ant), cgoAllocsUnknown
	allocs5a1ffb63.Borrow(cant_allocs)

	x.ref5a1ffb63 = ref5a1ffb63
	x.allocs5a1ffb63 = allocs5a1ffb63
	return ref5a1ffb63, allocs5a1ffb63

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FreqRange) PassValue() (C.freq_range_t, *cgoAllocMap) {
	if x.ref5a1ffb63 != nil {
		return *x.ref5a1ffb63, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FreqRange) Deref() {
	if x.ref5a1ffb63 == nil {
		return
	}
	x.Start = (float64)(x.ref5a1ffb63.start)
	x.End = (float64)(x.ref5a1ffb63.end)
	x.Modes = (Rmode)(x.ref5a1ffb63.modes)
	x.LowPower = (int32)(x.ref5a1ffb63.low_power)
	x.HighPower = (int32)(x.ref5a1ffb63.high_power)
	x.Vfo = (int32)(x.ref5a1ffb63.vfo)
	x.Ant = (int32)(x.ref5a1ffb63.ant)
}

// allocChanMemory allocates memory for type C.chan_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocChanMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfChanValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfChanValue = unsafe.Sizeof([1]C.chan_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Chan) Ref() *C.chan_t {
	if x == nil {
		return nil
	}
	return x.ref3d786229
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Chan) Free() {
	if x != nil && x.allocs3d786229 != nil {
		x.allocs3d786229.(*cgoAllocMap).Free()
		x.ref3d786229 = nil
	}
}

// NewChanRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewChanRef(ref unsafe.Pointer) *Chan {
	if ref == nil {
		return nil
	}
	obj := new(Chan)
	obj.ref3d786229 = (*C.chan_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Chan) PassRef() (*C.chan_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3d786229 != nil {
		return x.ref3d786229, nil
	}
	mem3d786229 := allocChanMemory(1)
	ref3d786229 := (*C.chan_t)(mem3d786229)
	allocs3d786229 := new(cgoAllocMap)
	var cstart_allocs *cgoAllocMap
	ref3d786229.start, cstart_allocs = (C.int)(x.Start), cgoAllocsUnknown
	allocs3d786229.Borrow(cstart_allocs)

	var cend_allocs *cgoAllocMap
	ref3d786229.end, cend_allocs = (C.int)(x.End), cgoAllocsUnknown
	allocs3d786229.Borrow(cend_allocs)

	var c_type_allocs *cgoAllocMap
	ref3d786229._type, c_type_allocs = (C.chan_type_t)(x.Type), cgoAllocsUnknown
	allocs3d786229.Borrow(c_type_allocs)

	x.ref3d786229 = ref3d786229
	x.allocs3d786229 = allocs3d786229
	return ref3d786229, allocs3d786229

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Chan) PassValue() (C.chan_t, *cgoAllocMap) {
	if x.ref3d786229 != nil {
		return *x.ref3d786229, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Chan) Deref() {
	if x.ref3d786229 == nil {
		return
	}
	x.Start = (int32)(x.ref3d786229.start)
	x.End = (int32)(x.ref3d786229.end)
	x.Type = (ChanType)(x.ref3d786229._type)
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// packSRig reads sliced Go data structure out from plain C format.
func packSRig(v []Rig, ptr0 *C.RIG) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRigValue]C.RIG)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRigRef(unsafe.Pointer(&ptr1))
	}
}

type sliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

// packSSChannel reads sliced Go data structure out from plain C format.
func packSSChannel(v [][]Channel, ptr0 **C.channel_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.channel_t)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfChannelValue]C.channel_t)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewChannelRef(unsafe.Pointer(&ptr2))
		}
	}
}

// packSChan reads sliced Go data structure out from plain C format.
func packSChan(v []Chan, ptr0 *C.chan_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfChanValue]C.chan_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewChanRef(unsafe.Pointer(&ptr1))
	}
}

func (x ChanCb) PassRef() (ref *C.chan_cb_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if chanCb2D1ED0BDFunc == nil {
		chanCb2D1ED0BDFunc = x
	}
	return (*C.chan_cb_t)(C.chan_cb_t_2d1ed0bd), nil
}

func (x ChanCb) PassValue() (ref C.chan_cb_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if chanCb2D1ED0BDFunc == nil {
		chanCb2D1ED0BDFunc = x
	}
	return (C.chan_cb_t)(C.chan_cb_t_2d1ed0bd), nil
}

func NewChanCbRef(ref unsafe.Pointer) *ChanCb {
	return (*ChanCb)(ref)
}

//export chanCb2D1ED0BD
func chanCb2D1ED0BD(carg0 *C.RIG, carg1 **C.channel_t, carg2 C.int, carg3 *C.chan_t, carg4 unsafe.Pointer) C.int {
	if chanCb2D1ED0BDFunc != nil {
		var arg02d1ed0bd []Rig
		packSRig(arg02d1ed0bd, carg0)
		var arg12d1ed0bd [][]Channel
		packSSChannel(arg12d1ed0bd, carg1)
		arg22d1ed0bd := (int32)(carg2)
		var arg32d1ed0bd []Chan
		packSChan(arg32d1ed0bd, carg3)
		arg42d1ed0bd := (unsafe.Pointer)(unsafe.Pointer(carg4))
		ret2d1ed0bd := chanCb2D1ED0BDFunc(arg02d1ed0bd, arg12d1ed0bd, arg22d1ed0bd, arg32d1ed0bd, arg42d1ed0bd)
		ret, _ := (C.int)(ret2d1ed0bd), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var chanCb2D1ED0BDFunc ChanCb

// packSConfparams reads sliced Go data structure out from plain C format.
func packSConfparams(v []Confparams, ptr0 *C.struct_confparams) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructConfparamsValue]C.struct_confparams)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewConfparamsRef(unsafe.Pointer(&ptr1))
	}
}

func (x ConfvalCb) PassRef() (ref *C.confval_cb_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if confvalCb8D622DE4Func == nil {
		confvalCb8D622DE4Func = x
	}
	return (*C.confval_cb_t)(C.confval_cb_t_8d622de4), nil
}

func (x ConfvalCb) PassValue() (ref C.confval_cb_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if confvalCb8D622DE4Func == nil {
		confvalCb8D622DE4Func = x
	}
	return (C.confval_cb_t)(C.confval_cb_t_8d622de4), nil
}

func NewConfvalCbRef(ref unsafe.Pointer) *ConfvalCb {
	return (*ConfvalCb)(ref)
}

//export confvalCb8D622DE4
func confvalCb8D622DE4(carg0 *C.RIG, carg1 *C.struct_confparams, carg2 *C.value_t, carg3 unsafe.Pointer) C.int {
	if confvalCb8D622DE4Func != nil {
		var arg08d622de4 []Rig
		packSRig(arg08d622de4, carg0)
		var arg18d622de4 []Confparams
		packSConfparams(arg18d622de4, carg1)
		var arg28d622de4 []Value
		hxfc4425b := (*sliceHeader)(unsafe.Pointer(&arg28d622de4))
		hxfc4425b.Data = uintptr(unsafe.Pointer(carg2))
		hxfc4425b.Cap = 0x7fffffff
		// hxfc4425b.Len = ?

		arg38d622de4 := (unsafe.Pointer)(unsafe.Pointer(carg3))
		ret8d622de4 := confvalCb8D622DE4Func(arg08d622de4, arg18d622de4, arg28d622de4, arg38d622de4)
		ret, _ := (C.int)(ret8d622de4), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var confvalCb8D622DE4Func ConfvalCb

// Ref returns a reference to C object as it is.
func (x *Port) Ref() *C.hamlib_port_t {
	if x == nil {
		return nil
	}
	return (*C.hamlib_port_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Port) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPortRef converts the C object reference into a raw struct reference without wrapping.
func NewPortRef(ref unsafe.Pointer) *Port {
	return (*Port)(ref)
}

// NewPort allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPort() *Port {
	return (*Port)(allocPortMemory(1))
}

// allocPortMemory allocates memory for type C.hamlib_port_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPortMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPortValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPortValue = unsafe.Sizeof([1]C.hamlib_port_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Port) PassRef() *C.hamlib_port_t {
	if x == nil {
		x = (*Port)(allocPortMemory(1))
	}
	return (*C.hamlib_port_t)(unsafe.Pointer(x))
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

type stringHeader struct {
	Data uintptr
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(unsafe.Pointer(h.Data)), C.int(h.Len))
}

func (x VprintfCb) PassRef() (ref *C.vprintf_cb_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if vprintfCbFDDF9323Func == nil {
		vprintfCbFDDF9323Func = x
	}
	return (*C.vprintf_cb_t)(C.vprintf_cb_t_fddf9323), nil
}

func (x VprintfCb) PassValue() (ref C.vprintf_cb_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if vprintfCbFDDF9323Func == nil {
		vprintfCbFDDF9323Func = x
	}
	return (C.vprintf_cb_t)(C.vprintf_cb_t_fddf9323), nil
}

func NewVprintfCbRef(ref unsafe.Pointer) *VprintfCb {
	return (*VprintfCb)(ref)
}

//export vprintfCbFDDF9323
func vprintfCbFDDF9323(carg0 C.enum_rig_debug_level_e, carg1 unsafe.Pointer, carg2 *C.char, carg3 unsafe.Pointer) C.int {
	if vprintfCbFDDF9323Func != nil {
		arg0fddf9323 := (RigDebugLevelE)(carg0)
		arg1fddf9323 := (unsafe.Pointer)(unsafe.Pointer(carg1))
		arg2fddf9323 := packPCharString(carg2)
		arg3fddf9323 := (unsafe.Pointer)(unsafe.Pointer(carg3))
		retfddf9323 := vprintfCbFDDF9323Func(arg0fddf9323, arg1fddf9323, arg2fddf9323, arg3fddf9323)
		ret, _ := (C.int)(retfddf9323), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var vprintfCbFDDF9323Func VprintfCb

func (x FreqCb) PassRef() (ref *C.freq_cb_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if freqCb8C3D2C4CFunc == nil {
		freqCb8C3D2C4CFunc = x
	}
	return (*C.freq_cb_t)(C.freq_cb_t_8c3d2c4c), nil
}

func (x FreqCb) PassValue() (ref C.freq_cb_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if freqCb8C3D2C4CFunc == nil {
		freqCb8C3D2C4CFunc = x
	}
	return (C.freq_cb_t)(C.freq_cb_t_8c3d2c4c), nil
}

func NewFreqCbRef(ref unsafe.Pointer) *FreqCb {
	return (*FreqCb)(ref)
}

//export freqCb8C3D2C4C
func freqCb8C3D2C4C(carg0 *C.RIG, carg1 C.vfo_t, carg2 C.freq_t, carg3 unsafe.Pointer) C.int {
	if freqCb8C3D2C4CFunc != nil {
		var arg08c3d2c4c []Rig
		packSRig(arg08c3d2c4c, carg0)
		arg18c3d2c4c := (int32)(carg1)
		arg28c3d2c4c := (float64)(carg2)
		arg38c3d2c4c := (unsafe.Pointer)(unsafe.Pointer(carg3))
		ret8c3d2c4c := freqCb8C3D2C4CFunc(arg08c3d2c4c, arg18c3d2c4c, arg28c3d2c4c, arg38c3d2c4c)
		ret, _ := (C.int)(ret8c3d2c4c), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var freqCb8C3D2C4CFunc FreqCb

func (x ModeCb) PassRef() (ref *C.mode_cb_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if modeCbD7E6DD52Func == nil {
		modeCbD7E6DD52Func = x
	}
	return (*C.mode_cb_t)(C.mode_cb_t_d7e6dd52), nil
}

func (x ModeCb) PassValue() (ref C.mode_cb_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if modeCbD7E6DD52Func == nil {
		modeCbD7E6DD52Func = x
	}
	return (C.mode_cb_t)(C.mode_cb_t_d7e6dd52), nil
}

func NewModeCbRef(ref unsafe.Pointer) *ModeCb {
	return (*ModeCb)(ref)
}

//export modeCbD7E6DD52
func modeCbD7E6DD52(carg0 *C.RIG, carg1 C.vfo_t, carg2 C.rmode_t, carg3 C.pbwidth_t, carg4 unsafe.Pointer) C.int {
	if modeCbD7E6DD52Func != nil {
		var arg0d7e6dd52 []Rig
		packSRig(arg0d7e6dd52, carg0)
		arg1d7e6dd52 := (int32)(carg1)
		arg2d7e6dd52 := (Rmode)(carg2)
		arg3d7e6dd52 := (int)(carg3)
		arg4d7e6dd52 := (unsafe.Pointer)(unsafe.Pointer(carg4))
		retd7e6dd52 := modeCbD7E6DD52Func(arg0d7e6dd52, arg1d7e6dd52, arg2d7e6dd52, arg3d7e6dd52, arg4d7e6dd52)
		ret, _ := (C.int)(retd7e6dd52), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var modeCbD7E6DD52Func ModeCb

func (x VfoCb) PassRef() (ref *C.vfo_cb_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if vfoCbAC116829Func == nil {
		vfoCbAC116829Func = x
	}
	return (*C.vfo_cb_t)(C.vfo_cb_t_ac116829), nil
}

func (x VfoCb) PassValue() (ref C.vfo_cb_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if vfoCbAC116829Func == nil {
		vfoCbAC116829Func = x
	}
	return (C.vfo_cb_t)(C.vfo_cb_t_ac116829), nil
}

func NewVfoCbRef(ref unsafe.Pointer) *VfoCb {
	return (*VfoCb)(ref)
}

//export vfoCbAC116829
func vfoCbAC116829(carg0 *C.RIG, carg1 C.vfo_t, carg2 unsafe.Pointer) C.int {
	if vfoCbAC116829Func != nil {
		var arg0ac116829 []Rig
		packSRig(arg0ac116829, carg0)
		arg1ac116829 := (int32)(carg1)
		arg2ac116829 := (unsafe.Pointer)(unsafe.Pointer(carg2))
		retac116829 := vfoCbAC116829Func(arg0ac116829, arg1ac116829, arg2ac116829)
		ret, _ := (C.int)(retac116829), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var vfoCbAC116829Func VfoCb

func (x PttCb) PassRef() (ref *C.ptt_cb_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pttCbF32E1E11Func == nil {
		pttCbF32E1E11Func = x
	}
	return (*C.ptt_cb_t)(C.ptt_cb_t_f32e1e11), nil
}

func (x PttCb) PassValue() (ref C.ptt_cb_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pttCbF32E1E11Func == nil {
		pttCbF32E1E11Func = x
	}
	return (C.ptt_cb_t)(C.ptt_cb_t_f32e1e11), nil
}

func NewPttCbRef(ref unsafe.Pointer) *PttCb {
	return (*PttCb)(ref)
}

//export pttCbF32E1E11
func pttCbF32E1E11(carg0 *C.RIG, carg1 C.vfo_t, carg2 C.ptt_t, carg3 unsafe.Pointer) C.int {
	if pttCbF32E1E11Func != nil {
		var arg0f32e1e11 []Rig
		packSRig(arg0f32e1e11, carg0)
		arg1f32e1e11 := (int32)(carg1)
		arg2f32e1e11 := (Ptt)(carg2)
		arg3f32e1e11 := (unsafe.Pointer)(unsafe.Pointer(carg3))
		retf32e1e11 := pttCbF32E1E11Func(arg0f32e1e11, arg1f32e1e11, arg2f32e1e11, arg3f32e1e11)
		ret, _ := (C.int)(retf32e1e11), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pttCbF32E1E11Func PttCb

func (x DcdCb) PassRef() (ref *C.dcd_cb_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if dcdCbAA70811BFunc == nil {
		dcdCbAA70811BFunc = x
	}
	return (*C.dcd_cb_t)(C.dcd_cb_t_aa70811b), nil
}

func (x DcdCb) PassValue() (ref C.dcd_cb_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if dcdCbAA70811BFunc == nil {
		dcdCbAA70811BFunc = x
	}
	return (C.dcd_cb_t)(C.dcd_cb_t_aa70811b), nil
}

func NewDcdCbRef(ref unsafe.Pointer) *DcdCb {
	return (*DcdCb)(ref)
}

//export dcdCbAA70811B
func dcdCbAA70811B(carg0 *C.RIG, carg1 C.vfo_t, carg2 C.dcd_t, carg3 unsafe.Pointer) C.int {
	if dcdCbAA70811BFunc != nil {
		var arg0aa70811b []Rig
		packSRig(arg0aa70811b, carg0)
		arg1aa70811b := (int32)(carg1)
		arg2aa70811b := (Dcd)(carg2)
		arg3aa70811b := (unsafe.Pointer)(unsafe.Pointer(carg3))
		retaa70811b := dcdCbAA70811BFunc(arg0aa70811b, arg1aa70811b, arg2aa70811b, arg3aa70811b)
		ret, _ := (C.int)(retaa70811b), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var dcdCbAA70811BFunc DcdCb

func (x PltuneCb) PassRef() (ref *C.pltune_cb_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pltuneCb26F9489AFunc == nil {
		pltuneCb26F9489AFunc = x
	}
	return (*C.pltune_cb_t)(C.pltune_cb_t_26f9489a), nil
}

func (x PltuneCb) PassValue() (ref C.pltune_cb_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pltuneCb26F9489AFunc == nil {
		pltuneCb26F9489AFunc = x
	}
	return (C.pltune_cb_t)(C.pltune_cb_t_26f9489a), nil
}

func NewPltuneCbRef(ref unsafe.Pointer) *PltuneCb {
	return (*PltuneCb)(ref)
}

//export pltuneCb26F9489A
func pltuneCb26F9489A(carg0 *C.RIG, carg1 C.vfo_t, carg2 *C.freq_t, carg3 *C.rmode_t, carg4 *C.pbwidth_t, carg5 unsafe.Pointer) C.int {
	if pltuneCb26F9489AFunc != nil {
		var arg026f9489a []Rig
		packSRig(arg026f9489a, carg0)
		arg126f9489a := (int32)(carg1)
		var arg226f9489a []float64
		hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&arg226f9489a))
		hxf95e7c8.Data = uintptr(unsafe.Pointer(carg2))
		hxf95e7c8.Cap = 0x7fffffff
		// hxf95e7c8.Len = ?

		var arg326f9489a []Rmode
		hxff2234b := (*sliceHeader)(unsafe.Pointer(&arg326f9489a))
		hxff2234b.Data = uintptr(unsafe.Pointer(carg3))
		hxff2234b.Cap = 0x7fffffff
		// hxff2234b.Len = ?

		var arg426f9489a []int
		hxff73280 := (*sliceHeader)(unsafe.Pointer(&arg426f9489a))
		hxff73280.Data = uintptr(unsafe.Pointer(carg4))
		hxff73280.Cap = 0x7fffffff
		// hxff73280.Len = ?

		arg526f9489a := (unsafe.Pointer)(unsafe.Pointer(carg5))
		ret26f9489a := pltuneCb26F9489AFunc(arg026f9489a, arg126f9489a, arg226f9489a, arg326f9489a, arg426f9489a, arg526f9489a)
		ret, _ := (C.int)(ret26f9489a), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pltuneCb26F9489AFunc PltuneCb

func (x RigProbeFunc) PassRef() (ref *C.rig_probe_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rigProbeFuncCE8C6199Func == nil {
		rigProbeFuncCE8C6199Func = x
	}
	return (*C.rig_probe_func_t)(C.rig_probe_func_t_ce8c6199), nil
}

func (x RigProbeFunc) PassValue() (ref C.rig_probe_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rigProbeFuncCE8C6199Func == nil {
		rigProbeFuncCE8C6199Func = x
	}
	return (C.rig_probe_func_t)(C.rig_probe_func_t_ce8c6199), nil
}

func NewRigProbeFuncRef(ref unsafe.Pointer) *RigProbeFunc {
	return (*RigProbeFunc)(ref)
}

//export rigProbeFuncCE8C6199
func rigProbeFuncCE8C6199(carg0 *C.hamlib_port_t, carg1 C.rig_model_t, carg2 unsafe.Pointer) C.int {
	if rigProbeFuncCE8C6199Func != nil {
		arg0ce8c6199 := NewPortRef(unsafe.Pointer(carg0))
		arg1ce8c6199 := (RigModel)(carg1)
		arg2ce8c6199 := (unsafe.Pointer)(unsafe.Pointer(carg2))
		retce8c6199 := rigProbeFuncCE8C6199Func(arg0ce8c6199, arg1ce8c6199, arg2ce8c6199)
		ret, _ := (C.int)(retce8c6199), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var rigProbeFuncCE8C6199Func RigProbeFunc

// allocStructConfparamsMemory allocates memory for type C.struct_confparams in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructConfparamsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructConfparamsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructConfparamsValue = unsafe.Sizeof([1]C.struct_confparams{})

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Confparams) Ref() *C.struct_confparams {
	if x == nil {
		return nil
	}
	return x.ref8d683b0d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Confparams) Free() {
	if x != nil && x.allocs8d683b0d != nil {
		x.allocs8d683b0d.(*cgoAllocMap).Free()
		x.ref8d683b0d = nil
	}
}

// NewConfparamsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConfparamsRef(ref unsafe.Pointer) *Confparams {
	if ref == nil {
		return nil
	}
	obj := new(Confparams)
	obj.ref8d683b0d = (*C.struct_confparams)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Confparams) PassRef() (*C.struct_confparams, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8d683b0d != nil {
		return x.ref8d683b0d, nil
	}
	mem8d683b0d := allocStructConfparamsMemory(1)
	ref8d683b0d := (*C.struct_confparams)(mem8d683b0d)
	allocs8d683b0d := new(cgoAllocMap)
	var ctoken_allocs *cgoAllocMap
	ref8d683b0d.token, ctoken_allocs = (C.token_t)(x.Token), cgoAllocsUnknown
	allocs8d683b0d.Borrow(ctoken_allocs)

	var cname_allocs *cgoAllocMap
	ref8d683b0d.name, cname_allocs = unpackPCharString(x.Name)
	allocs8d683b0d.Borrow(cname_allocs)

	var clabel_allocs *cgoAllocMap
	ref8d683b0d.label, clabel_allocs = unpackPCharString(x.Label)
	allocs8d683b0d.Borrow(clabel_allocs)

	var ctooltip_allocs *cgoAllocMap
	ref8d683b0d.tooltip, ctooltip_allocs = unpackPCharString(x.Tooltip)
	allocs8d683b0d.Borrow(ctooltip_allocs)

	var cdflt_allocs *cgoAllocMap
	ref8d683b0d.dflt, cdflt_allocs = unpackPCharString(x.Dflt)
	allocs8d683b0d.Borrow(cdflt_allocs)

	var c_type_allocs *cgoAllocMap
	ref8d683b0d._type, c_type_allocs = (C.enum_rig_conf_e)(x.Type), cgoAllocsUnknown
	allocs8d683b0d.Borrow(c_type_allocs)

	x.ref8d683b0d = ref8d683b0d
	x.allocs8d683b0d = allocs8d683b0d
	return ref8d683b0d, allocs8d683b0d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Confparams) PassValue() (C.struct_confparams, *cgoAllocMap) {
	if x.ref8d683b0d != nil {
		return *x.ref8d683b0d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Confparams) Deref() {
	if x.ref8d683b0d == nil {
		return
	}
	x.Token = (int)(x.ref8d683b0d.token)
	x.Name = packPCharString(x.ref8d683b0d.name)
	x.Label = packPCharString(x.ref8d683b0d.label)
	x.Tooltip = packPCharString(x.ref8d683b0d.tooltip)
	x.Dflt = packPCharString(x.ref8d683b0d.dflt)
	x.Type = (RigConfE)(x.ref8d683b0d._type)
}

// Ref returns a reference to C object as it is.
func (x *RigCaps) Ref() *C.struct_rig_caps {
	if x == nil {
		return nil
	}
	return (*C.struct_rig_caps)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *RigCaps) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewRigCapsRef converts the C object reference into a raw struct reference without wrapping.
func NewRigCapsRef(ref unsafe.Pointer) *RigCaps {
	return (*RigCaps)(ref)
}

// NewRigCaps allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewRigCaps() *RigCaps {
	return (*RigCaps)(allocStructRigCapsMemory(1))
}

// allocStructRigCapsMemory allocates memory for type C.struct_rig_caps in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructRigCapsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructRigCapsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructRigCapsValue = unsafe.Sizeof([1]C.struct_rig_caps{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *RigCaps) PassRef() *C.struct_rig_caps {
	if x == nil {
		x = (*RigCaps)(allocStructRigCapsMemory(1))
	}
	return (*C.struct_rig_caps)(unsafe.Pointer(x))
}

// allocChannelMemory allocates memory for type C.channel_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocChannelMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfChannelValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfChannelValue = unsafe.Sizeof([1]C.channel_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Channel) Ref() *C.channel_t {
	if x == nil {
		return nil
	}
	return x.ref9eaa335d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Channel) Free() {
	if x != nil && x.allocs9eaa335d != nil {
		x.allocs9eaa335d.(*cgoAllocMap).Free()
		x.ref9eaa335d = nil
	}
}

// NewChannelRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewChannelRef(ref unsafe.Pointer) *Channel {
	if ref == nil {
		return nil
	}
	obj := new(Channel)
	obj.ref9eaa335d = (*C.channel_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Channel) PassRef() (*C.channel_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9eaa335d != nil {
		return x.ref9eaa335d, nil
	}
	mem9eaa335d := allocChannelMemory(1)
	ref9eaa335d := (*C.channel_t)(mem9eaa335d)
	allocs9eaa335d := new(cgoAllocMap)
	var cchannel_num_allocs *cgoAllocMap
	ref9eaa335d.channel_num, cchannel_num_allocs = (C.int)(x.ChannelNum), cgoAllocsUnknown
	allocs9eaa335d.Borrow(cchannel_num_allocs)

	var cbank_num_allocs *cgoAllocMap
	ref9eaa335d.bank_num, cbank_num_allocs = (C.int)(x.BankNum), cgoAllocsUnknown
	allocs9eaa335d.Borrow(cbank_num_allocs)

	var cvfo_allocs *cgoAllocMap
	ref9eaa335d.vfo, cvfo_allocs = (C.vfo_t)(x.Vfo), cgoAllocsUnknown
	allocs9eaa335d.Borrow(cvfo_allocs)

	var cant_allocs *cgoAllocMap
	ref9eaa335d.ant, cant_allocs = (C.int)(x.Ant), cgoAllocsUnknown
	allocs9eaa335d.Borrow(cant_allocs)

	var cfreq_allocs *cgoAllocMap
	ref9eaa335d.freq, cfreq_allocs = (C.freq_t)(x.Freq), cgoAllocsUnknown
	allocs9eaa335d.Borrow(cfreq_allocs)

	var cmode_allocs *cgoAllocMap
	ref9eaa335d.mode, cmode_allocs = (C.rmode_t)(x.Mode), cgoAllocsUnknown
	allocs9eaa335d.Borrow(cmode_allocs)

	var cwidth_allocs *cgoAllocMap
	ref9eaa335d.width, cwidth_allocs = (C.pbwidth_t)(x.Width), cgoAllocsUnknown
	allocs9eaa335d.Borrow(cwidth_allocs)

	var ctx_freq_allocs *cgoAllocMap
	ref9eaa335d.tx_freq, ctx_freq_allocs = (C.freq_t)(x.TxFreq), cgoAllocsUnknown
	allocs9eaa335d.Borrow(ctx_freq_allocs)

	var ctx_mode_allocs *cgoAllocMap
	ref9eaa335d.tx_mode, ctx_mode_allocs = (C.rmode_t)(x.TxMode), cgoAllocsUnknown
	allocs9eaa335d.Borrow(ctx_mode_allocs)

	var ctx_width_allocs *cgoAllocMap
	ref9eaa335d.tx_width, ctx_width_allocs = (C.pbwidth_t)(x.TxWidth), cgoAllocsUnknown
	allocs9eaa335d.Borrow(ctx_width_allocs)

	var csplit_allocs *cgoAllocMap
	ref9eaa335d.split, csplit_allocs = (C.split_t)(x.Split), cgoAllocsUnknown
	allocs9eaa335d.Borrow(csplit_allocs)

	var ctx_vfo_allocs *cgoAllocMap
	ref9eaa335d.tx_vfo, ctx_vfo_allocs = (C.vfo_t)(x.TxVfo), cgoAllocsUnknown
	allocs9eaa335d.Borrow(ctx_vfo_allocs)

	var crptr_shift_allocs *cgoAllocMap
	ref9eaa335d.rptr_shift, crptr_shift_allocs = (C.rptr_shift_t)(x.RptrShift), cgoAllocsUnknown
	allocs9eaa335d.Borrow(crptr_shift_allocs)

	var crptr_offs_allocs *cgoAllocMap
	ref9eaa335d.rptr_offs, crptr_offs_allocs = (C.shortfreq_t)(x.RptrOffs), cgoAllocsUnknown
	allocs9eaa335d.Borrow(crptr_offs_allocs)

	var ctuning_step_allocs *cgoAllocMap
	ref9eaa335d.tuning_step, ctuning_step_allocs = (C.shortfreq_t)(x.TuningStep), cgoAllocsUnknown
	allocs9eaa335d.Borrow(ctuning_step_allocs)

	var crit_allocs *cgoAllocMap
	ref9eaa335d.rit, crit_allocs = (C.shortfreq_t)(x.Rit), cgoAllocsUnknown
	allocs9eaa335d.Borrow(crit_allocs)

	var cxit_allocs *cgoAllocMap
	ref9eaa335d.xit, cxit_allocs = (C.shortfreq_t)(x.Xit), cgoAllocsUnknown
	allocs9eaa335d.Borrow(cxit_allocs)

	var cfuncs_allocs *cgoAllocMap
	ref9eaa335d.funcs, cfuncs_allocs = (C.setting_t)(x.Funcs), cgoAllocsUnknown
	allocs9eaa335d.Borrow(cfuncs_allocs)

	var clevels_allocs *cgoAllocMap
	ref9eaa335d.levels, clevels_allocs = *(*[32]C.value_t)(unsafe.Pointer(&x.Levels)), cgoAllocsUnknown
	allocs9eaa335d.Borrow(clevels_allocs)

	var cctcss_tone_allocs *cgoAllocMap
	ref9eaa335d.ctcss_tone, cctcss_tone_allocs = (C.tone_t)(x.CtcssTone), cgoAllocsUnknown
	allocs9eaa335d.Borrow(cctcss_tone_allocs)

	var cctcss_sql_allocs *cgoAllocMap
	ref9eaa335d.ctcss_sql, cctcss_sql_allocs = (C.tone_t)(x.CtcssSql), cgoAllocsUnknown
	allocs9eaa335d.Borrow(cctcss_sql_allocs)

	var cdcs_code_allocs *cgoAllocMap
	ref9eaa335d.dcs_code, cdcs_code_allocs = (C.tone_t)(x.DcsCode), cgoAllocsUnknown
	allocs9eaa335d.Borrow(cdcs_code_allocs)

	var cdcs_sql_allocs *cgoAllocMap
	ref9eaa335d.dcs_sql, cdcs_sql_allocs = (C.tone_t)(x.DcsSql), cgoAllocsUnknown
	allocs9eaa335d.Borrow(cdcs_sql_allocs)

	var cscan_group_allocs *cgoAllocMap
	ref9eaa335d.scan_group, cscan_group_allocs = (C.int)(x.ScanGroup), cgoAllocsUnknown
	allocs9eaa335d.Borrow(cscan_group_allocs)

	var cflags_allocs *cgoAllocMap
	ref9eaa335d.flags, cflags_allocs = (C.int)(x.Flags), cgoAllocsUnknown
	allocs9eaa335d.Borrow(cflags_allocs)

	var cchannel_desc_allocs *cgoAllocMap
	ref9eaa335d.channel_desc, cchannel_desc_allocs = *(*[30]C.char)(unsafe.Pointer(&x.ChannelDesc)), cgoAllocsUnknown
	allocs9eaa335d.Borrow(cchannel_desc_allocs)

	x.ref9eaa335d = ref9eaa335d
	x.allocs9eaa335d = allocs9eaa335d
	return ref9eaa335d, allocs9eaa335d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Channel) PassValue() (C.channel_t, *cgoAllocMap) {
	if x.ref9eaa335d != nil {
		return *x.ref9eaa335d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Channel) Deref() {
	if x.ref9eaa335d == nil {
		return
	}
	x.ChannelNum = (int32)(x.ref9eaa335d.channel_num)
	x.BankNum = (int32)(x.ref9eaa335d.bank_num)
	x.Vfo = (int32)(x.ref9eaa335d.vfo)
	x.Ant = (int32)(x.ref9eaa335d.ant)
	x.Freq = (float64)(x.ref9eaa335d.freq)
	x.Mode = (Rmode)(x.ref9eaa335d.mode)
	x.Width = (int)(x.ref9eaa335d.width)
	x.TxFreq = (float64)(x.ref9eaa335d.tx_freq)
	x.TxMode = (Rmode)(x.ref9eaa335d.tx_mode)
	x.TxWidth = (int)(x.ref9eaa335d.tx_width)
	x.Split = (Split)(x.ref9eaa335d.split)
	x.TxVfo = (int32)(x.ref9eaa335d.tx_vfo)
	x.RptrShift = (RptrShift)(x.ref9eaa335d.rptr_shift)
	x.RptrOffs = (int)(x.ref9eaa335d.rptr_offs)
	x.TuningStep = (int)(x.ref9eaa335d.tuning_step)
	x.Rit = (int)(x.ref9eaa335d.rit)
	x.Xit = (int)(x.ref9eaa335d.xit)
	x.Funcs = (uint)(x.ref9eaa335d.funcs)
	x.Levels = *(*[32]Value)(unsafe.Pointer(&x.ref9eaa335d.levels))
	x.CtcssTone = (uint32)(x.ref9eaa335d.ctcss_tone)
	x.CtcssSql = (uint32)(x.ref9eaa335d.ctcss_sql)
	x.DcsCode = (uint32)(x.ref9eaa335d.dcs_code)
	x.DcsSql = (uint32)(x.ref9eaa335d.dcs_sql)
	x.ScanGroup = (int32)(x.ref9eaa335d.scan_group)
	x.Flags = (int32)(x.ref9eaa335d.flags)
	x.ChannelDesc = *(*[30]byte)(unsafe.Pointer(&x.ref9eaa335d.channel_desc))
}

// Ref returns a reference to C object as it is.
func (x *RigState) Ref() *C.struct_rig_state {
	if x == nil {
		return nil
	}
	return (*C.struct_rig_state)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *RigState) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewRigStateRef converts the C object reference into a raw struct reference without wrapping.
func NewRigStateRef(ref unsafe.Pointer) *RigState {
	return (*RigState)(ref)
}

// NewRigState allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewRigState() *RigState {
	return (*RigState)(allocStructRigStateMemory(1))
}

// allocStructRigStateMemory allocates memory for type C.struct_rig_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructRigStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructRigStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructRigStateValue = unsafe.Sizeof([1]C.struct_rig_state{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *RigState) PassRef() *C.struct_rig_state {
	if x == nil {
		x = (*RigState)(allocStructRigStateMemory(1))
	}
	return (*C.struct_rig_state)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *RigCallbacks) Ref() *C.struct_rig_callbacks {
	if x == nil {
		return nil
	}
	return (*C.struct_rig_callbacks)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *RigCallbacks) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewRigCallbacksRef converts the C object reference into a raw struct reference without wrapping.
func NewRigCallbacksRef(ref unsafe.Pointer) *RigCallbacks {
	return (*RigCallbacks)(ref)
}

// NewRigCallbacks allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewRigCallbacks() *RigCallbacks {
	return (*RigCallbacks)(allocStructRigCallbacksMemory(1))
}

// allocStructRigCallbacksMemory allocates memory for type C.struct_rig_callbacks in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructRigCallbacksMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructRigCallbacksValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructRigCallbacksValue = unsafe.Sizeof([1]C.struct_rig_callbacks{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *RigCallbacks) PassRef() *C.struct_rig_callbacks {
	if x == nil {
		x = (*RigCallbacks)(allocStructRigCallbacksMemory(1))
	}
	return (*C.struct_rig_callbacks)(unsafe.Pointer(x))
}

// unpackArgSChannel transforms a sliced Go data structure into plain C format.
func unpackArgSChannel(x []Channel) (unpacked *C.channel_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.channel_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocChannelMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.channel_t)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.channel_t)(unsafe.Pointer(h.Data))
	return
}

// packSChannel reads sliced Go data structure out from plain C format.
func packSChannel(v []Channel, ptr0 *C.channel_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfChannelValue]C.channel_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewChannelRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSConfparams transforms a sliced Go data structure into plain C format.
func unpackArgSConfparams(x []Confparams) (unpacked *C.struct_confparams, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_confparams) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructConfparamsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_confparams)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_confparams)(unsafe.Pointer(h.Data))
	return
}
